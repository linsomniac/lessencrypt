#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#  "cryptography",
#  "jinja2",
#  "dnspython",
# ]
# ///
"""
LessEncrypt Server

Manages client connections, key processing, and certificate generation.
"""

import argparse
import base64
import configparser
import datetime
import hashlib
import ipaddress
import logging
import os
import random
import re
import socket
import sys
import threading
from pathlib import Path
from re import Pattern
from typing import Any, Dict, List, Optional, Tuple

import dns.resolver
import dns.reversename
from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.x509.oid import NameOID
from jinja2 import Template

DEFAULT_PORT = 334
DEFAULT_TIMEOUT = 60
DEFAULT_CONFIG_FILE = "/etc/lessencrypt/lessencrypt.conf"
DEFAULT_MAPPING_FILE = "/etc/lessencrypt/name_mapping.conf"


def parse_protocol_message(message: str) -> Dict[str, str]:
    """Parse a protocol message into key-value pairs.

    Args:
        message: Protocol message string (e.g., "keyreq v=1 pubkey=ABC123")

    Returns:
        Dictionary of key-value pairs from the message
    """
    parts = message.strip().split()
    result = {}

    for part in parts:
        if "=" in part:
            key, value = part.split("=", 1)
            result[key] = value
        else:
            # For parts without =, use the part itself as both key and value
            # This handles cases like "keyreq" or "lessencrypt"
            result[part] = part

    return result


def generate_random_hex_serial() -> int:
    """Generate a random serial number as 16 lowercase hex digits.

    Returns:
        The serial number as an integer parsed from the hex string.
    """
    # Generate 16 random hex digits (64 bits)
    hex_serial = "".join(random.choice("0123456789abcdef") for _ in range(16))
    # Convert to integer
    return int(hex_serial, 16)


class ServerConfig:
    """Server configuration."""

    def __init__(self, config_file: Path) -> None:
        """Initialize server configuration from a file."""
        # Check if config file exists before trying to read it
        if not config_file.exists():
            error_msg = f"Fatal error: Configuration file {config_file} does not exist"
            logging.error(error_msg)
            print(error_msg, file=sys.stderr)
            sys.exit(1)

        # Try to read the config file
        try:
            config = configparser.ConfigParser()
            # Use read_file instead of read to get immediate error if file can't be read
            with open(config_file, "r") as f:
                config.read_file(f)
        except (configparser.Error, IOError) as e:
            error_msg = (
                f"Fatal error: Could not read configuration file {config_file}: {e}"
            )
            logging.error(error_msg)
            print(error_msg, file=sys.stderr)
            sys.exit(1)

        try:
            self.listen_address = config.get(
                "server", "listen_address", fallback="0.0.0.0"
            )
            self.port = config.getint("server", "port", fallback=DEFAULT_PORT)
            self.timeout = config.getint("server", "timeout", fallback=DEFAULT_TIMEOUT)

            # These values are required and have no fallbacks
            self.ca_cert_file = Path(config.get("server", "ca_cert_file"))
            self.ca_key_file = Path(config.get("server", "ca_key_file"))
            self.ca_key_password = config.get(
                "server", "ca_key_password", fallback=None
            )

            self.cert_country = config.get("certificate", "country", fallback="US")
            self.cert_state = config.get("certificate", "state", fallback="California")
            self.cert_locality = config.get(
                "certificate", "locality", fallback="San Francisco"
            )
            self.cert_organization = config.get(
                "certificate", "organization", fallback="LessEncrypt"
            )
            self.cert_validity_days = config.getint(
                "certificate", "validity_days", fallback=365
            )

            self.name_mapping_file = Path(
                config.get("server", "mappings", fallback=DEFAULT_MAPPING_FILE)
            )

            # Security settings
            self.allow_high_ports = config.getboolean(
                "server", "allow_high_ports", fallback=False
            )

            # Authentication settings
            self.shared_secret = config.get("server", "shared_secret", fallback=None)
        except (configparser.NoSectionError, configparser.NoOptionError) as e:
            error_msg = (
                f"Fatal error: Missing required configuration in {config_file}: {e}"
            )
            logging.error(error_msg)
            print(error_msg, file=sys.stderr)
            sys.exit(1)


def load_ca_cert_and_key(
    config: ServerConfig,
) -> Tuple[x509.Certificate, rsa.RSAPrivateKey]:
    """Load the CA certificate and private key."""
    with open(config.ca_cert_file, "rb") as f:
        ca_cert = x509.load_pem_x509_certificate(f.read())

    with open(config.ca_key_file, "rb") as f:
        if config.ca_key_password:
            password = config.ca_key_password.encode()
        else:
            password = None
        ca_key = serialization.load_pem_private_key(f.read(), password=password)

    if not isinstance(ca_key, rsa.RSAPrivateKey):
        raise TypeError("CA key is not an RSA private key")

    return ca_cert, ca_key


def parse_name_mapping(
    mapping_file: Path,
) -> Tuple[List[Tuple[Pattern[str], str, Dict[str, str]]], Dict[str, str]]:
    """Parse the name mapping file.

    Returns:
        A tuple containing:
        - A list of tuples with (regex_pattern, template_str, config_overrides)
        - A dictionary of global config overrides (applied to all matches)
    """
    logging.info(f"Parsing name mapping file: {mapping_file}")
    mappings = []
    global_overrides = {}  # Global overrides that apply to all entries
    line_number = 0

    with open(mapping_file, "r") as f:
        for line in f:
            line_number += 1
            line = line.strip()
            if not line or line.startswith("#"):
                logging.debug(f"Line {line_number}: Skipping comment or empty line")
                continue

            # Extract the regex and template parts
            match = re.match(r"^/(.*)/\s+(.*)$", line)
            if not match:
                # Check if it's a global override (not tied to a pattern)
                if line.startswith("set:"):
                    try:
                        _, config_setting = line.split("set:", 1)
                        if "=" in config_setting:
                            config_key, config_value = config_setting.split("=", 1)
                            global_overrides[config_key.strip()] = config_value.strip()
                            logging.debug(
                                f"Line {line_number}: Added global config override '{config_key}={config_value}'"
                            )
                        else:
                            logging.warning(
                                f"Line {line_number}: Invalid global config setting format: {line}"
                            )
                            print(
                                f"Invalid global config setting format: {line}",
                                file=sys.stderr,
                            )
                    except ValueError:
                        logging.warning(
                            f"Line {line_number}: Invalid setting format: {line}"
                        )
                        print(f"Invalid setting format: {line}", file=sys.stderr)
                else:
                    logging.warning(
                        f"Line {line_number}: Invalid mapping format: {line}"
                    )
                    print(f"Invalid mapping line: {line}", file=sys.stderr)
                continue

            regex_str, template_part = match.groups()

            # Extract any set: directives from the template part
            template_words = template_part.split()
            template_str_parts = []
            config_overrides = {}

            for word in template_words:
                if word.startswith("set:"):
                    try:
                        _, config_setting = word.split("set:", 1)
                        if "=" in config_setting:
                            config_key, config_value = config_setting.split("=", 1)
                            config_overrides[config_key.strip()] = config_value.strip()
                            logging.debug(
                                f"Line {line_number}: Added config override '{config_key}={config_value}'"
                            )
                        else:
                            logging.warning(
                                f"Line {line_number}: Invalid config setting format: {word}"
                            )
                            template_str_parts.append(
                                word
                            )  # Keep it as is if format is invalid
                    except ValueError:
                        logging.warning(
                            f"Line {line_number}: Invalid setting format: {word}"
                        )
                        template_str_parts.append(
                            word
                        )  # Keep it as is if format is invalid
                else:
                    template_str_parts.append(word)

            # Reconstruct the template string without set: directives
            template_str = " ".join(template_str_parts)

            logging.debug(
                f"Line {line_number}: Extracted regex='{regex_str}', template='{template_str}', overrides={config_overrides}"
            )
            try:
                regex = re.compile(regex_str)
                mappings.append((regex, template_str, config_overrides))
                logging.debug(f"Line {line_number}: Successfully compiled regex")
            except re.error as e:
                logging.warning(f"Line {line_number}: Invalid regex '{regex_str}': {e}")
                print(f"Invalid regex in mapping: {regex_str} - {e}", file=sys.stderr)

    logging.info(f"Loaded {len(mappings)} name mappings from {mapping_file}")
    logging.info(
        f"Loaded {len(global_overrides)} global config overrides from {mapping_file}"
    )
    return mappings, global_overrides


def lookup_reverse_dns(ip_address: str) -> Optional[str]:
    """Look up the reverse DNS of an IP address."""
    try:
        logging.debug(f"Converting {ip_address} to reverse address")
        addr = dns.reversename.from_address(ip_address)
        logging.debug(f"Looking up PTR record for {addr}")
        answers = dns.resolver.resolve(addr, "PTR")
        hostname = str(answers[0]).rstrip(".")
        logging.debug(f"Found hostname: {hostname}")
        return hostname
    except Exception as e:
        logging.warning(f"Reverse DNS lookup failed for {ip_address}: {e}")
        print(f"Reverse DNS lookup failed for {ip_address}: {e}", file=sys.stderr)
        return None


def apply_config_overrides(config: ServerConfig, overrides: Dict[str, str]) -> None:
    """Apply configuration overrides from mapping file set: directives.

    Supports overriding:
    - Server section: ca_cert_file, ca_key_file, ca_key_password
    - Certificate section: All values (country, state, locality, organization, validity_days)

    Format for keys:
    - Simple key: Applied to its default section (e.g., "ca_cert_file" for server section)
    - Section.key: Applied to specific section (e.g., "certificate.validity_days")
    """
    # Define which settings are allowed to be overridden
    allowed_server_settings = {"ca_cert_file", "ca_key_file", "ca_key_password"}
    allowed_cert_settings = {
        "country",
        "state",
        "locality",
        "organization",
        "validity_days",
    }

    for key, value in overrides.items():
        # Check if the key includes a section prefix
        if "." in key:
            section, setting = key.split(".", 1)

            if section == "server" and setting in allowed_server_settings:
                logging.debug(f"Applying server config override: {setting}={value}")

                if setting == "ca_cert_file":
                    config.ca_cert_file = Path(value)
                elif setting == "ca_key_file":
                    config.ca_key_file = Path(value)
                elif setting == "ca_key_password":
                    # Empty password means no password
                    config.ca_key_password = value if value else None

            elif section == "certificate" and setting in allowed_cert_settings:
                logging.debug(
                    f"Applying certificate config override: {setting}={value}"
                )

                if setting == "country":
                    config.cert_country = value
                elif setting == "state":
                    config.cert_state = value
                elif setting == "locality":
                    config.cert_locality = value
                elif setting == "organization":
                    config.cert_organization = value
                elif setting == "validity_days":
                    try:
                        config.cert_validity_days = int(value)
                    except ValueError:
                        logging.warning(
                            f"Invalid value for validity_days: {value}, must be an integer"
                        )

        # Handle keys without section prefix - assume appropriate section
        else:
            if key in allowed_server_settings:
                logging.debug(f"Applying server config override: {key}={value}")

                if key == "ca_cert_file":
                    config.ca_cert_file = Path(value)
                elif key == "ca_key_file":
                    config.ca_key_file = Path(value)
                elif key == "ca_key_password":
                    config.ca_key_password = value if value else None

            elif key in allowed_cert_settings:
                logging.debug(f"Applying certificate config override: {key}={value}")

                if key == "country":
                    config.cert_country = value
                elif key == "state":
                    config.cert_state = value
                elif key == "locality":
                    config.cert_locality = value
                elif key == "organization":
                    config.cert_organization = value
                elif key == "validity_days":
                    try:
                        config.cert_validity_days = int(value)
                    except ValueError:
                        logging.warning(
                            f"Invalid value for validity_days: {value}, must be an integer"
                        )

            else:
                logging.warning(f"Unknown config override setting: {key}")


def match_hostname(
    hostname: str, mappings: List[Tuple[Pattern[str], str, Dict[str, str]]]
) -> Tuple[Optional[List[str]], Dict[str, str]]:
    """Match a hostname against the name mappings.

    Returns:
        A tuple of (cert_names, config_overrides) where:
        - cert_names: List of certificate names (common name and SANs) or None if no match
        - config_overrides: Dict of configuration overrides from the matched mapping
    """
    logging.debug(f"Matching hostname: {hostname}")

    # Parse hostname into components
    parts = hostname.split(".")
    if len(parts) >= 2:
        host = parts[0]
        domain = ".".join(parts[1:])
        logging.debug(f"Parsed hostname into host={host}, domain={domain}")
    else:
        host = hostname
        domain = ""
        logging.debug(f"Hostname has no domain part, using host={host}")

    context = {
        "fqdn": hostname,
        "ip": "",  # Will be filled by the caller
        "host": host,
        "domain": domain,
    }

    # Try to match the hostname against the mappings
    for i, (regex, template_str, config_overrides) in enumerate(mappings):
        logging.debug(f"Trying mapping #{i+1}: /{regex.pattern}/")
        match = regex.search(hostname)
        if match:
            logging.debug(f"Matched regex: /{regex.pattern}/")

            # Add regex groups to the context
            # Add numbered groups as _1, _2, etc. (can't use bare numbers in Jinja2)
            for group_num in range(1, len(match.groups()) + 1):
                context[f"_{group_num}"] = match.group(group_num) or ""

            # Add named groups if any exist
            if match.groupdict():
                context.update(match.groupdict())
                logging.debug(f"Added named groups to context: {match.groupdict()}")

            logging.debug(f"Template context with groups: {context}")

            # Render the template
            template = Template(template_str)
            rendered = template.render(**context)
            cert_names = rendered.split()
            logging.debug(f"Template rendered to: {rendered}")
            logging.info(
                f"Hostname {hostname} matched to CN={cert_names[0]} and SANs={cert_names[1:] if len(cert_names) > 1 else []}"
            )
            return cert_names, config_overrides

    logging.debug(f"No mapping matched hostname: {hostname}")
    return None, {}


# Session key generation removed - no longer needed as we send unencrypted payload


def create_san_list(sans: List[str]) -> List[x509.GeneralName]:
    """Create a list of properly formatted Subject Alternative Names.

    IP addresses are formatted as x509.IPAddress, hostnames as x509.DNSName.
    """
    san_list: List[x509.GeneralName] = []
    for san in sans:
        try:
            # Try to parse as IP address
            ip = ipaddress.ip_address(san)
            san_list.append(x509.IPAddress(ip))
        except ValueError:
            # Not an IP address, treat as DNS name
            san_list.append(x509.DNSName(san))
    return san_list


def generate_certificate(
    public_key_pem: bytes,
    common_name: str,
    sans: List[str],
    ca_cert: x509.Certificate,
    ca_key: rsa.RSAPrivateKey,
    config: ServerConfig,
) -> x509.Certificate:
    """Generate a new certificate signed by the CA."""
    # Load the public key
    public_key = serialization.load_pem_public_key(public_key_pem)
    if not isinstance(public_key, rsa.RSAPublicKey):
        raise TypeError("Public key is not an RSA public key")

    # Create the certificate
    builder = x509.CertificateBuilder()  # type: ignore

    # Set the subject
    builder = builder.subject_name(
        x509.Name(
            [  # type: ignore
                x509.NameAttribute(NameOID.COUNTRY_NAME, config.cert_country),
                x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, config.cert_state),
                x509.NameAttribute(NameOID.LOCALITY_NAME, config.cert_locality),
                x509.NameAttribute(NameOID.ORGANIZATION_NAME, config.cert_organization),
                x509.NameAttribute(NameOID.COMMON_NAME, common_name),
            ]
        )
    )

    # Set the issuer (from the CA)
    builder = builder.issuer_name(ca_cert.subject)

    # Generate a random serial number (16 lowercase hex digits)
    builder = builder.serial_number(generate_random_hex_serial())

    # Set validity period
    now = datetime.datetime.now(datetime.timezone.utc)
    builder = builder.not_valid_before(now)
    builder = builder.not_valid_after(
        now + datetime.timedelta(days=config.cert_validity_days)
    )

    # Set the public key
    builder = builder.public_key(public_key)

    # Add extensions
    builder = builder.add_extension(
        x509.BasicConstraints(ca=False, path_length=None),
        critical=True,
    )

    builder = builder.add_extension(
        x509.KeyUsage(
            digital_signature=True,
            content_commitment=False,
            key_encipherment=True,
            data_encipherment=False,
            key_agreement=False,
            key_cert_sign=False,
            crl_sign=False,
            encipher_only=False,
            decipher_only=False,
        ),
        critical=True,
    )

    builder = builder.add_extension(
        x509.ExtendedKeyUsage(
            [
                x509.oid.ExtendedKeyUsageOID.SERVER_AUTH,
                x509.oid.ExtendedKeyUsageOID.CLIENT_AUTH,
            ]
        ),
        critical=False,
    )

    # Add Subject Alternative Names (SANs) - CN is always the first SAN
    all_sans = [common_name] + sans
    san_list = create_san_list(all_sans)
    builder = builder.add_extension(
        x509.SubjectAlternativeName(san_list),
        critical=False,
    )

    # Sign the certificate with the CA key
    certificate = builder.sign(
        private_key=ca_key,
        algorithm=hashes.SHA256(),
    )

    return certificate


def prepare_payload(
    payload: bytes, client_public_key: rsa.RSAPublicKey, ca_cert: x509.Certificate
) -> bytes:
    """Prepare the payload for delivery to the client.

    Since the payload is public information (certificates), we no longer encrypt it.
    We return the client certificate followed by the CA certificate.
    """
    # Get CA certificate in PEM format
    ca_cert_bytes = ca_cert.public_bytes(serialization.Encoding.PEM)

    # Combine client certificate and CA certificate
    combined_payload = payload + ca_cert_bytes

    return combined_payload


def handle_client(
    client_socket: socket.socket,
    client_address: Tuple[str, int],
    config: ServerConfig,
    ca_cert: x509.Certificate,
    ca_key: rsa.RSAPrivateKey,
    mappings: List[Tuple[Pattern[str], str, Dict[str, str]]],
) -> None:
    """Handle a client connection."""
    client_ip = client_address[0]
    client_port = client_address[1]
    logging.info(f"Handling client {client_ip}:{client_port}")

    try:
        # Send initial protocol message with optional challenge
        challenge = None
        if config.shared_secret:
            # Generate 32 random base64 characters
            challenge_bytes = base64.b64encode(
                os.urandom(24)
            )  # 24 bytes = 32 base64 chars
            challenge = challenge_bytes.decode("ascii")
            logging.debug(f"Sending lessencrypt message with challenge: {challenge}")
            client_socket.sendall(f"lessencrypt challenge={challenge}\n".encode())
        else:
            logging.debug("Sending lessencrypt message without challenge")
            client_socket.sendall(b"lessencrypt\n")

        # Look up reverse DNS
        logging.info(f"Looking up reverse DNS for {client_ip}")
        hostname = lookup_reverse_dns(client_ip)
        if not hostname:
            logging.warning(f"Failed to resolve hostname for {client_ip}")
            client_socket.sendall(b"error msg=Failed to resolve hostname\n")
            return

        logging.info(f"Resolved {client_ip} to {hostname}")

        # Match hostname against mappings
        logging.debug(f"Matching hostname {hostname} against name mappings")
        cert_names, match_overrides = match_hostname(hostname, mappings)
        if not cert_names:
            logging.warning(f"No mapping found for hostname {hostname}")
            client_socket.sendall(
                f"error msg=No mapping found for {hostname}\n".encode()
            )
            return

        # Create a new config for this request based on the existing one
        # This allows per-request configuration overrides without affecting other requests
        # We'll do a deep copy by transferring all values without reading the config file again
        request_config = ServerConfig.__new__(ServerConfig)

        # Manually copy all attributes from original config
        request_config.listen_address = config.listen_address
        request_config.port = config.port
        request_config.timeout = config.timeout
        request_config.ca_cert_file = config.ca_cert_file
        request_config.ca_key_file = config.ca_key_file
        request_config.ca_key_password = config.ca_key_password
        request_config.cert_country = config.cert_country
        request_config.cert_state = config.cert_state
        request_config.cert_locality = config.cert_locality
        request_config.cert_organization = config.cert_organization
        request_config.cert_validity_days = config.cert_validity_days
        request_config.name_mapping_file = config.name_mapping_file
        request_config.allow_high_ports = config.allow_high_ports

        # Apply any configuration overrides from the mapping
        if match_overrides:
            logging.info(
                f"Applying {len(match_overrides)} mapping-specific configuration overrides"
            )
            apply_config_overrides(request_config, match_overrides)

            # If CA config was changed, reload the CA cert and key
            if any(
                k in match_overrides or f"server.{k}" in match_overrides
                for k in ["ca_cert_file", "ca_key_file", "ca_key_password"]
            ):
                logging.info(f"CA configuration changed, reloading CA cert and key")
                logging.debug(f"Using CA cert: {request_config.ca_cert_file}")
                logging.debug(f"Using CA key: {request_config.ca_key_file}")
                ca_cert, ca_key = load_ca_cert_and_key(request_config)
                logging.debug(f"Reloaded CA certificate subject: {ca_cert.subject}")

        common_name = cert_names[0]
        sans = cert_names[1:]
        logging.info(f"Using common name {common_name} for certificate")
        logging.debug(f"Using SANs: {sans}")

        # Log certificate configuration that will be used
        logging.debug(
            f"Certificate will use: country={request_config.cert_country}, "
            + f"state={request_config.cert_state}, "
            + f"locality={request_config.cert_locality}, "
            + f"organization={request_config.cert_organization}, "
            + f"validity_days={request_config.cert_validity_days}"
        )

        # Read the key request
        logging.debug("Waiting for key request from client")
        raw_data = client_socket.recv(8192)
        try:
            data = raw_data.decode("utf-8")
            logging.debug(f"Client sent data: {data}")

            if not data:
                logging.debug(f"Client hung up")
                client_socket.close()
                return

            # Parse the protocol message
            params = parse_protocol_message(data)

            # Validate the request format
            if "keyreq" not in params or params.get("v") != "1":
                logging.warning("Invalid key request format")
                client_socket.sendall(b"error msg=Invalid key request format\n")
                return

            # Verify challenge response if we have a shared secret
            if config.shared_secret:
                if "challenge_response" not in params:
                    logging.warning(
                        "Shared secret configured but no challenge response received"
                    )
                    client_socket.sendall(b"error msg=Challenge response required\n")
                    return

                if challenge is None:
                    logging.error(
                        "Internal error: challenge is None but shared_secret is configured"
                    )
                    client_socket.sendall(b"error msg=Internal server error\n")
                    return

                # Calculate expected response
                expected_response = hashlib.sha256(
                    (config.shared_secret + challenge).encode("utf-8")
                ).hexdigest()

                if params["challenge_response"] != expected_response:
                    logging.warning("Invalid challenge response")
                    client_socket.sendall(b"error msg=Invalid challenge response\n")
                    return

                logging.debug("Challenge response verified successfully")

            # Use the client's source port for connecting back
            logging.debug(
                f"Will connect back to client on port {client_port} (source port)"
            )

            # Extract the public key
            if "pubkey" not in params:
                logging.warning("No public key in request")
                client_socket.sendall(b"error msg=Missing public key in request\n")
                return

            pubkey_b64 = params["pubkey"]
            logging.debug("Received public key (base64 encoded)")
        except UnicodeDecodeError:
            logging.warning("Invalid encoding in key request")
            client_socket.sendall(b"error msg=Invalid encoding in key request\n")
            return
        try:
            pubkey_pem = base64.b64decode(pubkey_b64)
            client_public_key = serialization.load_pem_public_key(pubkey_pem)
            if not isinstance(client_public_key, rsa.RSAPublicKey):
                logging.warning("Received key is not an RSA public key")
                raise TypeError("Public key is not an RSA public key")
            logging.debug("Successfully loaded RSA public key")
        except Exception as e:
            logging.warning(f"Invalid public key: {e}")
            client_socket.sendall(f"error msg=Invalid public key: {e}\n".encode())
            return

        # Send acknowledgment
        logging.debug("Sending acknowledgment to client")
        client_socket.sendall(b"ok\n")
        client_socket.close()

        # Generate a certificate
        logging.info("Generating certificate")
        certificate = generate_certificate(
            pubkey_pem, common_name, sans, ca_cert, ca_key, request_config
        )
        logging.debug(
            f"Certificate generated with serial number {certificate.serial_number} (hex: {certificate.serial_number:x})"
        )

        # Serialize the certificate
        cert_bytes = certificate.public_bytes(serialization.Encoding.PEM)
        logging.debug(f"Certificate serialized ({len(cert_bytes)} bytes)")

        # Prepare payload (no encryption needed as it's public information)
        logging.debug("Preparing certificate payload (client cert + CA cert)")
        payload = prepare_payload(cert_bytes, client_public_key, ca_cert)
        logging.debug(
            f"Payload size: {len(payload)} bytes (includes client cert and CA cert)"
        )

        # Check if client port is allowed
        if client_port >= 1024 and not config.allow_high_ports:
            logging.warning(
                f"Refusing to connect back to high port {client_port} (allow_high_ports=false)"
            )
            raise ValueError(
                f"Security policy prohibits connection to high ports (>= 1024): {client_port}"
            )

        # Connect back to the client on the requested port
        logging.info(f"Connecting back to client at {hostname}:{client_port}")
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(config.timeout)
            try:
                sock.connect((hostname, client_port))
                logging.debug(f"Successfully connected to {hostname}:{client_port}")
            except Exception as e:
                logging.error(f"Failed to connect to {hostname}:{client_port}: {e}")
                raise

            # Send the certificate
            logging.debug("Sending certificate to client")
            # Make sure there's a clear separation between the text header and payload
            sock.sendall(f"cert v=2 payloadlength={len(payload)}\n".encode())

            # Small delay to ensure header and payload don't get mixed in TCP buffer
            import time

            time.sleep(0.1)

            # Send the payload
            sock.sendall(payload)
            logging.info("Certificate delivery completed successfully")

    except Exception as e:
        logging.error(f"Error handling client {client_ip}: {e}", exc_info=True)
        print(f"Error handling client {client_ip}: {e}", file=sys.stderr)
        try:
            client_socket.sendall(f"error msg={str(e)}\n".encode())
        except:
            logging.debug("Failed to send error message to client")
            pass


def test_mappings(config: ServerConfig, hostnames: List[str]) -> int:
    """Test hostname mappings and display results."""
    try:
        # Load mappings
        mappings, global_overrides = parse_name_mapping(config.name_mapping_file)

        # Apply global overrides to config for testing
        if global_overrides:
            apply_config_overrides(config, global_overrides)

        print(
            f"Testing {len(hostnames)} hostname(s) against {len(mappings)} mapping rule(s)"
        )
        print(f"Mapping file: {config.name_mapping_file}")
        if global_overrides:
            print(f"Global overrides: {global_overrides}")
        print()

        for hostname in hostnames:
            print(f"Hostname: {hostname}")
            cert_names, match_overrides = match_hostname(hostname, mappings)

            if cert_names:
                cn = cert_names[0]
                sans = cert_names
                print(f"  CN: {cn}")
                if sans:
                    print(f"  SANs: {', '.join(sans)}")
                else:
                    print(f"  SANs: (none)")

                if match_overrides:
                    print(f"  Config overrides: {match_overrides}")
            else:
                print(f"  No mapping found")
            print()

        return 0
    except Exception as e:
        print(f"Error testing mappings: {e}", file=sys.stderr)
        return 1


def main() -> int:
    """Main function for the LessEncrypt server."""
    parser = argparse.ArgumentParser(description="LessEncrypt Server")
    parser.add_argument(
        "--config",
        type=Path,
        default=DEFAULT_CONFIG_FILE,
        help="Path to configuration file",
    )
    parser.add_argument(
        "--listen", help="IP address to listen on (overrides config file)"
    )
    parser.add_argument(
        "--port", type=int, help="Port to listen on (overrides config file)"
    )
    parser.add_argument(
        "--timeout",
        type=int,
        help="Connection timeout in seconds (overrides config file)",
    )
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose logging (INFO level)",
    )
    parser.add_argument(
        "--debug",
        action="store_true",
        help="Enable debug logging (DEBUG level)",
    )
    parser.add_argument(
        "--test-mappings",
        action="store_true",
        help="Test hostname mappings instead of running server",
    )
    parser.add_argument(
        "hostnames",
        nargs="*",
        help="Hostnames to test (only used with --test-mappings)",
    )
    args = parser.parse_args()

    # Configure logging
    log_format = "%(asctime)s - %(levelname)s - %(message)s"
    if args.debug:
        logging.basicConfig(level=logging.DEBUG, format=log_format)
        logging.debug("Debug logging enabled")
    elif args.verbose:
        logging.basicConfig(level=logging.INFO, format=log_format)
        logging.info("Verbose logging enabled")
    else:
        logging.basicConfig(level=logging.WARNING, format=log_format)

    try:
        # Load configuration
        config = ServerConfig(args.config)
        logging.info(f"Configuration loaded from {args.config}")

        # Handle test mappings mode
        if args.test_mappings:
            if not args.hostnames:
                print(
                    "Error: --test-mappings requires at least one hostname",
                    file=sys.stderr,
                )
                return 1
            return test_mappings(config, args.hostnames)

        # Apply command-line overrides
        if args.listen:
            logging.info(f"Overriding listen address with {args.listen}")
            config.listen_address = args.listen
        if args.port:
            logging.info(f"Overriding port with {args.port}")
            config.port = args.port
        if args.timeout:
            logging.info(f"Overriding timeout with {args.timeout} seconds")
            config.timeout = args.timeout

        # Load CA certificate and key
        logging.info(f"Loading CA certificate from {config.ca_cert_file}")
        logging.info(f"Loading CA key from {config.ca_key_file}")
        ca_cert, ca_key = load_ca_cert_and_key(config)
        logging.debug(f"CA certificate subject: {ca_cert.subject}")

        # Parse name mappings and global overrides
        logging.info(f"Loading name mappings from {config.name_mapping_file}")
        mappings, global_overrides = parse_name_mapping(config.name_mapping_file)
        logging.debug(f"Loaded {len(mappings)} name mappings")

        # Apply global configuration overrides
        if global_overrides:
            logging.info(
                f"Applying {len(global_overrides)} global configuration overrides"
            )
            apply_config_overrides(config, global_overrides)

        # Create the server socket
        logging.info("Creating server socket")
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_socket.bind((config.listen_address, config.port))
        server_socket.listen(5)

        logging.info(f"Server listening on {config.listen_address}:{config.port}")
        print(f"Server listening on {config.listen_address}:{config.port}")

        while True:
            # Accept client connections
            client_socket, client_address = server_socket.accept()
            logging.info(
                f"Accepted connection from {client_address[0]}:{client_address[1]}"
            )
            client_socket.settimeout(config.timeout)

            # Handle the client in a new thread
            logging.debug(f"Starting client handler thread for {client_address[0]}")
            thread = threading.Thread(
                target=handle_client,
                args=(client_socket, client_address, config, ca_cert, ca_key, mappings),
            )
            thread.daemon = True
            thread.start()

    except KeyboardInterrupt:
        logging.info("Server stopped by user")
        print("Server stopped by user", file=sys.stderr)
        return 0
    except Exception as e:
        logging.error(f"Server error: {e}", exc_info=True)
        print(f"Server error: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())

# vim: set filetype=python :
