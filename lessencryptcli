#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#  "cryptography",
# ]
# ///
"""
LessEncrypt Client

Handles key generation, server connection, and payload decryption.
"""

import argparse
import base64
import socket
import sys
from pathlib import Path
from typing import Optional, Tuple

from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa, padding
# We keep the padding import in case we need to handle v1 protocol in the future

DEFAULT_PORT = 334
DEFAULT_TIMEOUT = 60
DEFAULT_KEY_SIZE = 4096


def generate_keypair(
    key_size: int = DEFAULT_KEY_SIZE,
) -> Tuple[rsa.RSAPrivateKey, rsa.RSAPublicKey]:
    """Generate an RSA key pair with the specified key size."""
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=key_size,
    )
    public_key = private_key.public_key()
    return private_key, public_key


def public_key_to_base64(public_key: rsa.RSAPublicKey) -> str:
    """Serialize the public key to base64."""
    pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )
    return base64.b64encode(pem).decode("ascii")


def start_listener(port: int) -> socket.socket:
    """Start listening on the specified port."""
    listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listener.bind(("0.0.0.0", port))
    listener.listen(1)
    return listener


def parse_server_address(server_address: str, default_port: int) -> Tuple[str, int]:
    """Parse server address with optional port (format: hostname:port)."""
    if ":" in server_address:
        host, port_str = server_address.rsplit(":", 1)
        try:
            return host, int(port_str)
        except ValueError:
            # If port is not a valid integer, treat the whole string as the address
            return server_address, default_port
    return server_address, default_port


def connect_to_server(
    server_address: str, server_port: int, pubkey_b64: str, timeout: int, listening_port: int
) -> bool:
    """Connect to the server and send the public key."""
    try:
        # We're already listening on the specified port, so we can't bind to it directly.
        # Instead, we'll create a regular socket and let the OS assign a source port.
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(timeout)
            # We'll include the port we're listening on in the key request
            # so the server knows where to connect back to
            sock.connect((server_address, server_port))

            # Send the key request with our listening port
            message = f"keyreq v=1 port={listening_port} pubkey={pubkey_b64}\n"
            sock.sendall(message.encode())

            # Wait for server response
            response = sock.recv(1024).decode().strip()

            if response == "ok":
                return True
            elif response.startswith("error msg="):
                error_msg = response[10:]  # Skip "error msg="
                print(f"Server error: {error_msg}", file=sys.stderr)
                return False
            else:
                print(f"Unexpected server response: {response}", file=sys.stderr)
                return False
    except Exception as e:
        print(f"Connection error: {e}", file=sys.stderr)
        return False


def wait_for_certificate(
    listener: socket.socket,
    timeout: int,
    private_key: rsa.RSAPrivateKey,
    output_file: Path,
    passphrase: Optional[str] = None,
    key_file: Optional[Path] = None,
    ca_file: Optional[Path] = None,
) -> bool:
    """
    Wait for a certificate from the server and decrypt it. 
    
    Saves the private key, client certificate, and CA certificate according to the options:
    - If key_file is None, private key is included in output_file
    - If ca_file is None, CA certificate is included in output_file
    - If both key_file and ca_file are specified, only client cert is in output_file
    """
    listener.settimeout(timeout)
    try:
        conn, addr = listener.accept()
        with conn:
            # Read the certificate header (should be text)
            header_data = conn.recv(1024)
            try:
                # Try to find the newline separator between header and payload
                newline_pos = header_data.find(b'\n')
                if newline_pos == -1:
                    # If no newline found, assume it's all header
                    header = header_data.decode('utf-8')
                    remaining_data = b''
                else:
                    # Split into header and payload data
                    header = header_data[:newline_pos+1].decode('utf-8')
                    remaining_data = header_data[newline_pos+1:]
                
                # Check for both v1 (encrypted) and v2 (unencrypted) protocol versions
                if header.startswith("cert v=1 payloadlength="):
                    print("Warning: Server is using deprecated encrypted protocol v1", file=sys.stderr)
                    print("Please update server to use unencrypted protocol v2", file=sys.stderr)
                    return False
                elif header.startswith("cert v=2 payloadlength="):
                    # This is the current protocol version (unencrypted)
                    pass
                else:
                    print("Invalid certificate header", file=sys.stderr)
                    return False

                # Parse the payload length
                payload_length_str = header.split("payloadlength=")[1].split("\n")[0]
                payload_length = int(payload_length_str)
            except UnicodeDecodeError as e:
                print(f"Error decoding certificate header: {e}", file=sys.stderr)
                return False

            # Read the payload, starting with any data already received
            payload = remaining_data
            remaining = payload_length - len(payload)
            
            # Continue reading until we have the full payload
            while remaining > 0:
                chunk = conn.recv(min(4096, remaining))
                if not chunk:
                    break
                payload += chunk
                remaining -= len(chunk)

            if len(payload) != payload_length:
                print(
                    f"Incomplete payload: got {len(payload)} bytes, expected {payload_length}",
                    file=sys.stderr,
                )
                return False

            # In protocol v2, the payload is the certificate directly (no encryption)
            # The payload should contain both client cert and CA cert
            decrypted = payload
            
            # Split the client cert and CA cert if present
            # PEM certificates are delimited by the standard header/footer
            # Look for two certificates in the payload
            cert_parts = decrypted.split(b"-----BEGIN CERTIFICATE-----")
            
            if len(cert_parts) < 2:
                print("Warning: Payload does not contain multiple certificates. CA cert may be missing.", file=sys.stderr)
                client_cert = decrypted
                ca_cert = None
            else:
                # First part is empty (before first BEGIN marker)
                # Reconstruct the certificates with their headers
                client_cert = b"-----BEGIN CERTIFICATE-----" + cert_parts[1]
                if len(cert_parts) > 2:
                    ca_cert = b"-----BEGIN CERTIFICATE-----" + cert_parts[2]
                else:
                    ca_cert = None
            
            # Serialize the private key to PEM format
            if passphrase:
                # Encrypt the private key with the passphrase
                encryption_algorithm: serialization.KeySerializationEncryption = serialization.BestAvailableEncryption(passphrase.encode())
            else:
                # No encryption
                encryption_algorithm = serialization.NoEncryption()
                
            private_key_pem = private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=encryption_algorithm
            )
            
            # Determine where to write the key file
            key_file_path = key_file if key_file else output_file.with_suffix(".key")
            
            # Write the private key
            key_file_path.write_bytes(private_key_pem)
            
            # Handle writing the certificates according to options
            if ca_file and ca_cert:
                # Write CA cert to separate file
                ca_file.write_bytes(ca_cert)
                # Write only client cert to output file
                output_file.write_bytes(client_cert)
            elif ca_cert:
                # Combine client and CA certs in output file
                output_file.write_bytes(client_cert + ca_cert)
            else:
                # Only client cert available
                output_file.write_bytes(client_cert)
            
            # Success message already printed by the main function
            return True
    except socket.timeout:
        print(
            f"Timed out waiting for certificate after {timeout} seconds",
            file=sys.stderr,
        )
        return False
    except Exception as e:
        print(f"Error receiving certificate: {e}", file=sys.stderr)
        return False


def main() -> int:
    """Main function for the LessEncrypt client."""
    parser = argparse.ArgumentParser(description="LessEncrypt Client")
    parser.add_argument("server_address", help="Address of the LessEncrypt server")
    parser.add_argument(
        "output_file", type=Path, help="File to write the decrypted payload to"
    )
    parser.add_argument(
        "--port",
        type=int,
        default=DEFAULT_PORT,
        help="Port to connect to (default: 334, can also be specified as part of server_address using hostname:port format)",
    )
    parser.add_argument(
        "--timeout",
        type=int,
        default=DEFAULT_TIMEOUT,
        help="Timeout in seconds (default: 60)",
    )
    parser.add_argument(
        "--key-size",
        type=int,
        default=DEFAULT_KEY_SIZE,
        help="RSA key size in bits (default: 4096)",
    )
    parser.add_argument(
        "--passphrase",
        type=str,
        help="Passphrase to encrypt the private key (if not provided, the key is saved unencrypted)",
    )
    parser.add_argument(
        "--key-file",
        type=Path,
        help="Write the private key to this file (if specified, key is not included in output file)",
    )
    parser.add_argument(
        "--ca-file",
        type=Path,
        help="Write the CA certificate to this file (if specified, CA cert is not included in output file)",
    )
    args = parser.parse_args()

    # Generate RSA key pair
    print("Generating RSA key pair...")
    private_key, public_key = generate_keypair(args.key_size)
    pubkey_b64 = public_key_to_base64(public_key)

    # Parse the server address to check for embedded port
    server_host, server_port = parse_server_address(args.server_address, args.port)

    # Start listening for the certificate
    print(f"Starting listener on port {args.port}...")
    listener = start_listener(args.port)

    try:
        # Connect to the server and send the public key from the same port we're listening on
        print(f"Connecting to server {server_host}:{server_port} from port {args.port}...")
        if not connect_to_server(server_host, server_port, pubkey_b64, args.timeout, args.port):
            return 1

        # Wait for the certificate
        print("Waiting for certificate...")
        if not wait_for_certificate(
            listener, args.timeout, private_key, args.output_file, 
            args.passphrase, args.key_file, args.ca_file
        ):
            return 1

        print(f"Certificate saved to {args.output_file}")
        
        # Success message for key file
        key_file_path = args.key_file if args.key_file else args.output_file.with_suffix('.key')
        if args.passphrase:
            print(f"Encrypted private key saved to {key_file_path}")
        else:
            print(f"Private key saved to {key_file_path}")
            
        # Success message for CA file if specified
        if args.ca_file:
            print(f"CA certificate saved to {args.ca_file}")
            
        # Determine which files are included in output file
        if args.ca_file and args.key_file:
            print("Client certificate saved to output file")
            print(f"All files can be used directly with web servers like Apache or Nginx.")
        elif args.ca_file:
            print("Client certificate saved to output file (CA in separate file)")
            print(f"These files can be used directly with web servers like Apache or Nginx.")
        elif args.key_file:
            print("Client and CA certificates saved to output file")
            print(f"These files can be used directly with web servers like Apache or Nginx.")
        else:
            print("Client certificate, CA certificate, and private key files can be used directly with web servers like Apache or Nginx.")
        return 0
    finally:
        listener.close()


if __name__ == "__main__":
    sys.exit(main())

# vim: set filetype=python :
