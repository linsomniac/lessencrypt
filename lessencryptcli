#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = [
#  "cryptography",
# ]
# ///
"""
LessEncrypt Client

Handles key generation, server connection, and payload decryption.
"""

import argparse
import base64
import socket
import sys
from pathlib import Path
from typing import Optional, Tuple

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

DEFAULT_PORT = 334
DEFAULT_TIMEOUT = 60
DEFAULT_KEY_SIZE = 4096


def generate_keypair(
    key_size: int = DEFAULT_KEY_SIZE,
) -> Tuple[rsa.RSAPrivateKey, rsa.RSAPublicKey]:
    """Generate an RSA key pair with the specified key size."""
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=key_size,
    )
    public_key = private_key.public_key()
    return private_key, public_key


def public_key_to_base64(public_key: rsa.RSAPublicKey) -> str:
    """Serialize the public key to base64."""
    pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    )
    return base64.b64encode(pem).decode("ascii")


def start_listener(port: int) -> socket.socket:
    """Start listening on the specified port."""
    listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listener.bind(("0.0.0.0", port))
    listener.listen(1)
    return listener


def parse_server_address(server_address: str, default_port: int) -> Tuple[str, int]:
    """Parse server address with optional port (format: hostname:port)."""
    if ":" in server_address:
        host, port_str = server_address.rsplit(":", 1)
        try:
            return host, int(port_str)
        except ValueError:
            # If port is not a valid integer, treat the whole string as the address
            return server_address, default_port
    return server_address, default_port


def connect_to_server(
    server_address: str, server_port: int, pubkey_b64: str, timeout: int, listening_port: int
) -> bool:
    """Connect to the server and send the public key."""
    try:
        # We're already listening on the specified port, so we can't bind to it directly.
        # Instead, we'll create a regular socket and let the OS assign a source port.
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(timeout)
            # We'll include the port we're listening on in the key request
            # so the server knows where to connect back to
            sock.connect((server_address, server_port))

            # Send the key request with our listening port
            message = f"keyreq v=1 port={listening_port} pubkey={pubkey_b64}\n"
            sock.sendall(message.encode())

            # Wait for server response
            response = sock.recv(1024).decode().strip()

            if response == "ok":
                return True
            elif response.startswith("error msg="):
                error_msg = response[10:]  # Skip "error msg="
                print(f"Server error: {error_msg}", file=sys.stderr)
                return False
            else:
                print(f"Unexpected server response: {response}", file=sys.stderr)
                return False
    except Exception as e:
        print(f"Connection error: {e}", file=sys.stderr)
        return False


def wait_for_certificate(
    listener: socket.socket,
    timeout: int,
    private_key: rsa.RSAPrivateKey,
    output_file: Path,
    passphrase: Optional[str] = None,
) -> bool:
    """
    Wait for a certificate from the server and decrypt it. 
    Also saves the private key to a .key file, optionally encrypted with a passphrase.
    """
    listener.settimeout(timeout)
    try:
        conn, addr = listener.accept()
        with conn:
            # Read the certificate header (should be text)
            header_data = conn.recv(1024)
            try:
                # Try to find the newline separator between header and binary data
                newline_pos = header_data.find(b'\n')
                if newline_pos == -1:
                    # If no newline found, assume it's all header
                    header = header_data.decode('utf-8')
                    remaining_data = b''
                else:
                    # Split into header and binary data
                    header = header_data[:newline_pos+1].decode('utf-8')
                    remaining_data = header_data[newline_pos+1:]
                
                if not header.startswith("cert v=1 payloadlength="):
                    print("Invalid certificate header", file=sys.stderr)
                    return False

                # Parse the payload length
                payload_length_str = header.split("payloadlength=")[1].split("\n")[0]
                payload_length = int(payload_length_str)
            except UnicodeDecodeError as e:
                print(f"Error decoding certificate header: {e}", file=sys.stderr)
                return False

            # Read the payload, starting with any data already received
            payload = remaining_data
            remaining = payload_length - len(payload)
            
            # Continue reading until we have the full payload
            while remaining > 0:
                chunk = conn.recv(min(4096, remaining))
                if not chunk:
                    break
                payload += chunk
                remaining -= len(chunk)

            if len(payload) != payload_length:
                print(
                    f"Incomplete payload: got {len(payload)} bytes, expected {payload_length}",
                    file=sys.stderr,
                )
                return False

            # The first part of the payload is the encrypted session key
            # The rest is the encrypted certificate
            # We'll assume the first 512 bytes are the encrypted session key
            encrypted_session_key = payload[:512]
            encrypted_payload = payload[512:]

            # Decrypt the session key
            session_key = private_key.decrypt(
                encrypted_session_key,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None,
                ),
            )

            # Decrypt the payload using the session key
            # Assume the first 16 bytes of the encrypted payload are the IV
            iv = encrypted_payload[:16]
            ciphertext = encrypted_payload[16:]

            cipher = Cipher(algorithms.AES(session_key), modes.CBC(iv))
            decryptor = cipher.decryptor()  # type: ignore
            decrypted = decryptor.update(ciphertext) + decryptor.finalize()

            # Remove PKCS#7 padding
            padding_length = decrypted[-1]
            decrypted = decrypted[:-padding_length]

            # Serialize the private key to PEM format
            if passphrase:
                # Encrypt the private key with the passphrase
                encryption_algorithm = serialization.BestAvailableEncryption(passphrase.encode())
            else:
                # No encryption
                encryption_algorithm = serialization.NoEncryption()
                
            private_key_pem = private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.PKCS8,
                encryption_algorithm=encryption_algorithm
            )
            
            # Get the certificate file stem and parent directory
            key_file = output_file.with_suffix(".key")
            
            # Write the private key to the key file
            key_file.write_bytes(private_key_pem)
            
            # Write the decrypted certificate to the output file
            output_file.write_bytes(decrypted)
            
            # Success message already printed by the main function
            return True
    except socket.timeout:
        print(
            f"Timed out waiting for certificate after {timeout} seconds",
            file=sys.stderr,
        )
        return False
    except Exception as e:
        print(f"Error receiving certificate: {e}", file=sys.stderr)
        return False


def main() -> int:
    """Main function for the LessEncrypt client."""
    parser = argparse.ArgumentParser(description="LessEncrypt Client")
    parser.add_argument("server_address", help="Address of the LessEncrypt server")
    parser.add_argument(
        "output_file", type=Path, help="File to write the decrypted payload to"
    )
    parser.add_argument(
        "--port",
        type=int,
        default=DEFAULT_PORT,
        help="Port to connect to (default: 334, can also be specified as part of server_address using hostname:port format)",
    )
    parser.add_argument(
        "--timeout",
        type=int,
        default=DEFAULT_TIMEOUT,
        help="Timeout in seconds (default: 60)",
    )
    parser.add_argument(
        "--key-size",
        type=int,
        default=DEFAULT_KEY_SIZE,
        help="RSA key size in bits (default: 4096)",
    )
    parser.add_argument(
        "--passphrase",
        type=str,
        help="Passphrase to encrypt the private key (if not provided, the key is saved unencrypted)",
    )
    args = parser.parse_args()

    # Generate RSA key pair
    print("Generating RSA key pair...")
    private_key, public_key = generate_keypair(args.key_size)
    pubkey_b64 = public_key_to_base64(public_key)

    # Parse the server address to check for embedded port
    server_host, server_port = parse_server_address(args.server_address, args.port)

    # Start listening for the certificate
    print(f"Starting listener on port {args.port}...")
    listener = start_listener(args.port)

    try:
        # Connect to the server and send the public key from the same port we're listening on
        print(f"Connecting to server {server_host}:{server_port} from port {args.port}...")
        if not connect_to_server(server_host, server_port, pubkey_b64, args.timeout, args.port):
            return 1

        # Wait for the certificate
        print("Waiting for certificate...")
        if not wait_for_certificate(
            listener, args.timeout, private_key, args.output_file, args.passphrase
        ):
            return 1

        print(f"Certificate saved to {args.output_file}")
        key_file = args.output_file.with_suffix('.key')
        if args.passphrase:
            print(f"Encrypted private key saved to {key_file}")
        else:
            print(f"Private key saved to {key_file}")
        print("Both files can be used directly with web servers like Apache or Nginx.")
        return 0
    finally:
        listener.close()


if __name__ == "__main__":
    sys.exit(main())

# vim: set filetype=python :
